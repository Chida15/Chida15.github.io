<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[mac下安装dosbox]]></title>
    <url>%2F2019%2F10%2F02%2Fmac%E4%B8%8B%E5%AE%89%E8%A3%85dosbox%2F</url>
    <content type="text"><![CDATA[如何安装dosboxdosbox下载汇编开发工具下载创建一个工作目录1mkdir Assembly // 我是在~/MyAcademic/文件夹下创建的 将下载的汇编开发工具移动到该文件夹中 打开dosbox，输入：12mount c ~/myFiles/MyAcademic/Assemblyc: 即可进入创建的文件夹中输入debug，运行debug程序 输入q退出debug dosbox的一些设置mac下dosbox的设置文件在~/Library/Preferences/DOSBox 0.74-3 Preferences （1）自动挂载在设置文件中加入1mount c ~/myFiles/MyAcademic/Assembly // 后面是前面创建的放编译、链接工具的文件夹 （2）改变分辨率在设置文件中加入123456789101112131415161718[sdl]fullscreen=falsefulldouble=falsefullresolution=originalwindowresolution=1024x640 // 可以通过更改这里的分辨率调整大小output=openglautolock=truesensitivity=100waitοnerrοr=truepriority=higher,normalmapperfile=mapper-0.74.mapusescancodes=true[render]frameskip=0aspect=falsescaler=normal2x 注意：将自动挂载设置卸载改变分辨率设置前面，否则会出错。 参考1.https://www.jianshu.com/p/d762644e076b 2.https://blog.csdn.net/My__Code/article/details/79734754 3.https://blog.csdn.net/lvdan1/article/details/72675340]]></content>
      <categories>
        <category>Solutions</category>
      </categories>
      <tags>
        <tag>Assembly Language</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自顶向下方法第一章笔记]]></title>
    <url>%2F2019%2F09%2F30%2F%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95%E7%AC%AC%E4%B8%80%E7%AB%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[何为因特网具体构成通信链路由不同的物理媒体组成，如铜线（copper wire）、光纤（optical fiber）、同轴电缆（coaxial cable）和无线电频谱（radio spectrum）等。分组交换机最重要的两个分组交换机是路由器和链路层交换机，前者常用于网络核心中，后者常用于接入网中。ISP（Internet Service Provider）由多个分组交换机和链路组成的网络路由器和交换机的区别： 前者是网络层的分组交换机，后者是链路层的分组交换机；前者使用网络层IP地址转发分组，后者使用MAC地址转发分组；前者常用于网络核心部分，后者常用于接入网。 服务角度（因特网的基础设施）socket interfaceTCP/IP网络的应用程序编程接口（Application Programming Interface，API），它定义了很多函数或者例程，程序员可以用他们来开发TCP/IP网络上的应用程序。什么是协议协议定义了通信实体（两个或多个）之间交换消息的格式和顺序。协议既可以是硬件也可以是软件。协议存在于计算机、路由器、平板或其他可联网设备上。网络边缘接入网 物理媒体 网络核心分组交换为了向目标端系统发送信息，源端系统将长报文分成多个分组，每个分组通过通信链路和多个分组交换机最终到达目标端系统。存储转发（store-and-forward transmission）存储转发是指分组转换器在将分组的第一个比特转发之前，必须接收全部的分组。排队延时和分组丢失（Queuing Delays and Packet Loss）每个分组交换器都有一个输出缓存（输出队列）。当到达的分组需要传输到某个链路，而该链路正在传输其他分组（不同分组不能使用同一链路，同一分组的不同bit可以使用同一链路）时，该到达分组必须在输出缓存中等待。若缓存已满，则需要丢弃到达分组或排队分组。转发表和路由选择协议（Forwarding Tables and Routing Protocols）每个路由器中有一个转发表，其中将目标地址映射成路由器输出链路。每个分组的头部中包含了目标端系统的IP地址，当分组到达一个路由器时，该路由器检查分组的目标地址的一部分，然后搜索其转发表找到合适的输出链路。路由选择协议用于自动设置转发表，它可以决定从一个路由器到目标地址的最短路径，并使用这些最短路径来配置路由器中的转发表。电路交换传统的电话网络是一种电路交换网络。 电路交换在通信期间链路一直保留，且预留了带宽，因此链路的传输速率始终不变。 在下图的电路交换网络中，4条链路将4个电路交换机相互连接。每天链路包含四条电路，因此每条链路可同时支持4条并行连接。当两台主机要进行通信时，网络在两台主机之间建立了一条专用的端到端连接。因为每条链路有4条电路，该连接在连接期间获得链路宽带的1/4，比如每条链路具有1Mbps传输速率，则每个端到端电路交换连接获得250kbps专用的传输速率。 电路交换中的复用技术（未完待续。。。）]]></content>
      <categories>
        <category>Subjects</category>
      </categories>
      <tags>
        <tag>Computer Networking</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何给hexo博文加密]]></title>
    <url>%2F2019%2F09%2F30%2F%E5%A6%82%E4%BD%95%E7%BB%99hexo%E5%8D%9A%E6%96%87%E5%8A%A0%E5%AF%86%2F</url>
    <content type="text"><![CDATA[安装hexo插件1npm install hexo-blog-encrypt --save 对博客主目录下的_config.yml文件进行如下修改12encrypt: enable: true 在需要加密的博客的文件头中加入如下字段：123title: 如何给hexo博文加密date: 2019-09-30 10:40:54password: 密码]]></content>
      <categories>
        <category>Solutions</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何在hexo中添加图片（typora）]]></title>
    <url>%2F2019%2F09%2F29%2F%E5%A6%82%E4%BD%95%E5%9C%A8hexo%E4%B8%AD%E6%B7%BB%E5%8A%A0%E5%9B%BE%E7%89%87%EF%BC%88typora%EF%BC%89%2F</url>
    <content type="text"><![CDATA[相关设置在Mac下进入Typora的Preferences中 点击image选择自定义设置，即可将粘贴在typora的图片自动存放到hexo博文对应的文件夹中 设置图片保存的相对地址为：../../../../source（相对source文件夹的相对地址）修改图片的根目录进入博客目录下的scaffolds文件夹中，修改post.md如下：12345678---title: 如何在hexo中添加图片（typora）permalink: &#123;&#123; title &#125;&#125;date: &#123;&#123; date &#125;&#125;tags: categories: typora-root-url: ../../../../source # 加入这一行--- 在博文中插入截图的图片： 在博文中插入本机图片（无论该文件在哪里，都会自动加入source/images/对应博文名称的文件夹下）：]]></content>
      <categories>
        <category>Solutions</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mac终端iTerm2如何进行单词跳跃]]></title>
    <url>%2F2019%2F09%2F29%2Fmac%E7%BB%88%E7%AB%AFiTerm2%E5%A6%82%E4%BD%95%E8%BF%9B%E8%A1%8C%E5%8D%95%E8%AF%8D%E8%B7%B3%E8%B7%83%2F</url>
    <content type="text"><![CDATA[快捷键修改进入Preferences设置中 进入Profiles下的keys标签页 找到option+←和option+→两个快捷键（这里是已经修改后的） 进行如下修改 iTerm2下的一些快捷键光标移动至行首： ctrl + a光标移动至行位：ctrl + e删除当前行：ctrl + u当前位置开始清除至行尾：ctrl + k]]></content>
      <categories>
        <category>Solutions</category>
      </categories>
      <tags>
        <tag>Mac</tag>
        <tag>Terminal</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何对hexo中的文章进行分类管理]]></title>
    <url>%2F2019%2F09%2F29%2F%E5%A6%82%E4%BD%95%E5%AF%B9hexo%E4%B8%AD%E7%9A%84%E6%96%87%E7%AB%A0%E8%BF%9B%E8%A1%8C%E5%88%86%E7%B1%BB%E7%AE%A1%E7%90%86%2F</url>
    <content type="text"><![CDATA[在博客主目录下找到_config.yml文件，修改其中的new_post_name和permalink字段将new_post_name修改成如下格式：1new_post_name: :year/:month/:day/:title.md 如果觉得没必要精确到日的话，可以删除”:day/“ 将permalink修改成如下格式：1permalink: :year/:month/:day/:title/ 问题permalink中的title不是文章的题目，而是相对于source/_post/的相对路径因此需要在博客主目录下的scaffolds文件夹中修改post.md：1234567---title: &#123;&#123; title &#125;&#125;permalink: &#123;&#123; title &#125;&#125;date: &#123;&#123; date &#125;&#125;tags:categories:--- 参考https://blog.csdn.net/maosidiaoxian/article/details/85220394]]></content>
      <categories>
        <category>Solutions</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何给hexo博客添加标签]]></title>
    <url>%2F2019%2F09%2F29%2F%E5%A6%82%E4%BD%95%E7%BB%99hexo%E5%8D%9A%E5%AE%A2%E6%B7%BB%E5%8A%A0%E6%A0%87%E7%AD%BE%2F</url>
    <content type="text"><![CDATA[在source文件夹中执行：1hexo new page tags 这里的tags是标签页面的名字，也可以写中文的“标签”。 在新生成的tags文件夹中打开index.md，添加如下字段：1type: &quot;tags&quot; 注意：冒号后有一个空格 如果需要删除tags页的评论，添加如下字段：1comments: false 进入博客主目录下的themes文件夹，再进入所使用的的主题文件夹下，打开_config.yml文件，找到menu字段，添加tags字段：1234menu:home: /archives: /archives/tags: /tags/]]></content>
      <categories>
        <category>Solutions</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何将hexo博客从Ubuntu下迁移至Mac]]></title>
    <url>%2F2019%2F09%2F28%2F%E5%A6%82%E4%BD%95%E5%B0%86hexo%E5%8D%9A%E5%AE%A2%E4%BB%8EUbuntu%E4%B8%8B%E8%BF%81%E7%A7%BB%E8%87%B3Mac%2F</url>
    <content type="text"><![CDATA[迁移过程在Mac下安装git并添加公钥具体内容可以百度搜索，不过多赘述。下载Node.js此处下载拷贝原来的文件到新电脑中必须拷贝的文件有：_config.yml，theme/，source/，scaffolds/，package.json，.gitignore不需要拷贝的文件有：.git/，node_modules/，public/，.deploy_git/，db.json安装hexo在安装过程中，由于npm的镜像在国外，所以遇到了一些错误，后来改用淘宝的cnpm才得以解决，以下是方法：1npm install -g cnpm --registry=https://registry.npm.taobao.org 使用cnpm install命令进行模块安装注意不要使用hexo init安装deployer1install hexo-generator-git --save 遇到的问题插件重复安装在node_modules文件夹河package,json文件夹中删除相应的插件hexo clean使用出错把public中需要编译的内容（比如CNAME文件）移到source文件夹中，然后进行hexo clean。当执行hexo g的时候会重新创建pulic文件夹，复原其中的文件。无法部署新的文章到github上因为我使用了原来文件中的node_modules，可以删除它再cnmp install参考链接1.https://www.zhihu.com/question/21193762/answer/103097754]]></content>
      <categories>
        <category>Solutions</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何从零搭建unet网络]]></title>
    <url>%2F2019%2F07%2F09%2F%E5%A6%82%E4%BD%95%E4%BB%8E%E9%9B%B6%E6%90%AD%E5%BB%BAunet%E7%BD%91%E7%BB%9C%2F</url>
    <content type="text"><![CDATA[数据增强123456789101112'''数据增强'''import randomfrom PIL import Imagefrom torchvision import transformsimport torchvision.transforms.functional as tfimport osmask_path = './data/old_mask/'image_path = './data/old_images/'mask_save_path = './data/mask/'image_save_path = './data/images/'num = 100 123456789def RandomFilp(image, mask): '''随机翻转''' if random.random() &gt; 0.5: image = tf.hflip(image) mask = tf.hflip(mask) else: image = tf.vflip(image) mask = tf.vflip(mask) return image, mask 123456def RandomRotation(image, mask): '''随机旋转''' angle = transforms.RandomRotation.get_params([-180, 180]) image = tf.rotate(image, angle, resample=Image.NEAREST) mask = tf.rotate(mask, angle, resample=Image.NEAREST) return image, mask 1234567891011121314def RandomCrop(image, mask): '''随机裁剪''' if random.random() &gt; 0.5: i, j, h, w = transforms.RandomResizedCrop.get_params( image, scale=(0.5, 1.0), ratio = (1,1)) image = tf.resized_crop(image, i, j, h, w, (396, 476)) mask = tf.resized_crop(mask, i, j, h, w, (396, 476)) else: pad = random.randint(0, 192) image = tf.pad(image, pad) image = tf.resize(image, (396, 476)) mask = tf.pad(mask, pad) mask = tf.resize(mask, (396, 476)) return image, mask 1234567891011121314151617181920def transform(image, mask): # 旋转 # angle是-180到180的随机数 angle = transforms.RandomRotation.get_params([-180, 180]) image = tf.rotate(image, angle, resample=Image.NEAREST) mask = tf.rotate(mask, angle, resample=Image.NEAREST) # 随机翻转 if random.random() &gt; 0.5: image, mask = RandomFilp(image, mask) # 随机裁剪 if random.random() &gt; 0.5: image, mask = RandomCrop(image, mask) # 随机旋转 if random.random() &gt; 0.5: image, mask = RandomRotation(image, mask) return image, mask 123456789101112def Augmentation(): '''数据增强''' images_name = os.listdir(image_path) j = 1; for image_name in images_name: for i in range(num): image = Image.open(image_path + image_name) mask = Image.open(mask_path + image_name) new_image, new_mask = transform(image, mask) new_image.save(image_save_path + str(j) + '.png') new_mask.save(mask_save_path + str(j) + '.png') j += 1 12if __name__ == '__main__': Augmentation() Dataloader创建12345678from torch.utils.data import Dataset, DataLoader, random_splitimport torchvision.transforms as transformsimport osimport PIL.Image as Imageimport numpy as npimg_path = './data/images/'msk_path = './data/mask/' 123456transform = transforms.Compose([ transforms.ToTensor(), transforms.Normalize([0.5, 0.5, 0.5], [0.5, 0.5, 0.5])])target_transform = transforms.ToTensor() 12345678910111213141516171819202122class SpineData(Dataset): def __init__(self, transform=None, target_transform=None): self.transform = transform self.target_transform = target_transform def __len__(self): return len(os.listdir(img_path)) def __getitem__(self, idx): image_name = os.listdir(img_path)[idx] image = Image.open(img_path + image_name).convert('RGB') image = image.resize((256, 256)) # 统一大小可以加快训练速度 mask = Image.open(msk_path + image_name).convert('L') mask = mask.resize((256, 256)) # 将image和mask都转为Tensor格式 if self.target_transform: mask = self.target_transform(mask) if self.transform: image = self.transform(image) return image, mask 123456789101112spine_data = SpineData(transform, target_transform)train_size = int(0.9 * len(spine_data))test_sizee = len(spine_data) - train_sizetrainset, testset = random_split(spine_data, (train_size, test_sizee))trainloader = DataLoader(trainset, batch_size=4, shuffle=True, num_workers=2)testloader = DataLoader(testset)dataiter = iter(trainloader)img, msk = dataiter.next() Unet网络搭建123import torch.nn as nnimport torch.nn.functional as Fimport torch 12345678910111213class DoubleConv(nn.Module): def __init__(self,in_ch,out_ch): super(DoubleConv,self).__init__() self.conv = nn.Sequential( nn.Conv2d(in_ch,out_ch,3,padding=1),# in_ch、out_ch是通道数 nn.BatchNorm2d(out_ch), nn.ReLU(inplace = True), nn.Conv2d(out_ch,out_ch,3,padding=1), nn.BatchNorm2d(out_ch), nn.ReLU(inplace = True) ) def forward(self,x): return self.conv(x) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950class UNet(nn.Module): def __init__(self, in_ch, out_ch): super(UNet, self).__init__() super(UNet,self).__init__() self.conv1 = DoubleConv(in_ch,64) self.pool1 = nn.MaxPool2d(2) self.conv2 = DoubleConv(64,128) self.pool2 = nn.MaxPool2d(2) self.conv3 = DoubleConv(128,256) self.pool3 = nn.MaxPool2d(2) self.conv4 = DoubleConv(256,512) self.pool4 = nn.MaxPool2d(2) self.conv5 = DoubleConv(512,1024) #逆卷积 self.up6 = nn.ConvTranspose2d(1024,512,2,stride=2) self.conv6 = DoubleConv(1024,512) self.up7 = nn.ConvTranspose2d(512,256,2,stride=2) self.conv7 = DoubleConv(512,256) self.up8 = nn.ConvTranspose2d(256,128,2,stride=2) self.conv8 = DoubleConv(256,128) self.up9 = nn.ConvTranspose2d(128,64,2,stride=2) self.conv9 = DoubleConv(128,64) self.conv10 = nn.Conv2d(64,out_ch,1) def forward(self, x): c1 = self.conv1(x) p1 = self.pool1(c1) c2 = self.conv2(p1) p2 = self.pool2(c2) c3 = self.conv3(p2) p3 = self.pool3(c3) c4 = self.conv4(p3) p4 = self.pool4(c4) c5 = self.conv5(p4) up_6 = self.up6(c5) merge6 = torch.cat([up_6,c4],dim=1)# 按列拼接 c6 = self.conv6(merge6) up_7 = self.up7(c6) merge7 = torch.cat([up_7,c3],dim=1) c7 = self.conv7(merge7) up_8 = self.up8(c7) merge8 = torch.cat([up_8,c2],dim=1) c8 = self.conv8(merge8) up_9 = self.up9(c8) merge9 = torch.cat([up_9,c1],dim=1) c9 = self.conv9(merge9) c10 = self.conv10(c9) out = nn.Sigmoid()(c10)# 化成(0~1)区间 return out 网络训练与测试123456import torch.optim as optimfrom data_loader import trainloader, testloaderfrom unet import UNetimport torch.nn as nnimport torchimport numpy as np 12device = torch.device("cuda:0" if torch.cuda.is_available() else "cpu")model = UNet(3, 1) 1234567891011121314151617181920def train_model(model, criterion, optimizer, num_epochs=2): for epoch in range(num_epochs): print('Epoch &#123;&#125;/&#123;&#125;'.format(epoch, num_epochs - 1)) print('-' * 10) dataset_size = len(trainloader.dataset) epoch_loss = 0 step = 0 #minibatch数 for x, y in trainloader:# 分100次遍历数据集，每次遍历batch_size=4 optimizer.zero_grad()#每次minibatch都要将梯度(dw,db,...)清零 inputs = x labels = y outputs = model(inputs)#前向传播 loss = criterion(outputs, labels)#计算损失 loss.backward()#梯度下降,计算出梯度 optimizer.step()#更新参数一次：所有的优化器Optimizer都实现了step()方法来对所有的参数进行更新 epoch_loss += loss.item() step += 1 print("%d/%d,train_loss:%0.3f" % (step, dataset_size // trainloader.batch_size, loss.item())) print("epoch %d loss:%0.3f" % (epoch, epoch_loss)) 1234def train(): criterion = nn.BCELoss() optimizer = optim.Adam(model.parameters()) train_model(model, criterion, optimizer) 123456789101112131415161718import matplotlib.pyplot as pltdef test(): with torch.no_grad(): for idx, (x, _) in enumerate(testloader): y = model(x) print("y:") print(y) print(y.shape) img_y = torch.squeeze(y).numpy() # 去掉batch_size和channel,这两者均为1 print("img_y:") print(img_y) plt.imshow(img_y) print(img_y.shape) plt.axis('off') plt.subplots_adjust(top = 1, bottom = 0, right = 1, left = 0, hspace = 0, wspace = 0) plt.margins(0,0) print("./result/result&#123;&#125;.jpg".format(idx)) plt.savefig("./result/result&#123;&#125;.jpg".format(idx), dpi=100) 12train()test()]]></content>
      <categories>
        <category>DeepLearning</category>
      </categories>
      <tags>
        <tag>Architecture</tag>
        <tag>Unet</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PC端和ipad端如何同步PDF]]></title>
    <url>%2F2019%2F04%2F21%2FPC%E7%AB%AF%E5%92%8Cipad%E7%AB%AF%E5%A6%82%E4%BD%95%E5%90%8C%E6%AD%A5PDF%2F</url>
    <content type="text"><![CDATA[使用坚果云和福昕阅读器进行PC端和ipad端的PDF同步1. 在PC端和ipad端同时下载福昕阅读器2. PC端安装坚果云并注册坚果云账号账户信息——&gt;安全选项——&gt;添加应用然后可以得到应用密码，在后面会用到 3. 点击create sync folder设置需要同步的文件夹4. 在ipad端进行设置1.选择cloud点击add选择添加WebDAV2.输入Title，URL(地址是https://dav.jianguoyun.com/dav/),Login(你注册坚果云时候的邮箱)，password（你的坚果云密码），然后save，就可以访问你在PC端设置的同步文件夹了 无论是在PC端还是在ipad端修改PDF后，双方都会立即更新同步信息。]]></content>
      <categories>
        <category>Solutions</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[如何利用github pages打造自己的博客]]></title>
    <url>%2F2019%2F04%2F15%2F%E5%A6%82%E4%BD%95%E5%88%A9%E7%94%A8github%20pages%E6%89%93%E9%80%A0%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[打造自己的博客（github pages + Hexo + NextT）github创建仓库选择new repositories创建一个仓库，注意仓库的名字是用户名.github.io 安装Hexo1) 安装nodejsm1sudo apt-get install nodejs 2) 安装git1sudo apt-get install git 3) 安装npm1sudo apt-get install npm 4) npm换源(永久换成淘宝源)1npm config set registry https://registry.npm.taobao.org 5) 安装hexo1sudo npm install -g hexo-cli 建站１）创建一个文件夹（作为博客根目录），比如：1mkdir myBlog 2) 初始化博客1npm init myBlog 3) 安装必要依赖12cd myBlognpm install 4) 关联github pages12//在myBlog目录下执行gedit _config.ymｌ 找到deploy,更换成如下内容：1234deploy: type: git repository: git@github.com:用户名/用户名.github.io.git branch: master 换主题：NextT1) 从github上clone NexT1git clone https://github.com/iissnan/hexo-theme-next themes/next //在myBLog目录下执行 2) 更换主题打开myBlog目录下的_config.yml，找到theme: landscape改为theme: next 3) 运行hexo s查看效果 域名绑定1) 申请阿里云域名2) 域名解析在域名界面点击解析，再点击添加记录，分别添加以下两项记录：a)记录类型：CNAME主机记录：@解析线路：默认记录值：用户名.github.ioTTL：10分钟b)记录类型：CNAME主机记录：www解析线路：默认记录值：用户名.github.ioTTL：10分钟 最好使用CNAME，因为ip地址可能会改变。 美化nextT参考博客：http://jeffyang.top/Hexo/Hexo%E4%B8%BB%E9%A2%98Next%E7%BE%8E%E5%8C%96/https://www.jianshu.com/p/f054333ac9e6http://www.yangyong.xyz/2018/01/03/add-hexo-next-post-views/ 阅读次数http://duansm.top/2018/08/03/hexo-next/http://www.yamllint.com/ 检测yaml是否有问题 如何发表与删除文章1) 新建文章1234hexo new a // 生成post，新建并发布文章a，出现在source/_posts中hexo new draft b // 生成draft，新建草稿，出现在source/_drafts中hexo server --draft // 预览草稿hexo publish b // 发布草稿 默认hexo new是生成post，如果要改成其他的（比如draft），可以在myBlog下的_config.yml文件中找到default_layout进行修改，其参数值有：post，draft和page 2）删除文章进入source/_posts文件夹中，找到要删除的md文件，直接本地删除，然后依次执行12hexo ghexo]]></content>
      <categories>
        <category>Solutions</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
</search>
